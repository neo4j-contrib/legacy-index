Neo4j indexing utilities

	This is a collection of various utilities for indexing parts of a neo4j
	graph. The most straight-forward way to use this component is via
	the <<org.neo4j.util.index.IndexService>> interface. This <<IndexService>>
	is basically a service where you can index neo4j nodes with key-value pairs.
	See more below.

	There's also other useful utilities, such as <<Timeline>> and <<BTree>>,
	utilities which uses the neo4j graph itself for storing index information.

IndexService

	In the <<org.neo4j.util.index>> package you will find the <<IndexService>> 
	interface which holds the most straight-forward way of indexing your neo4j
	graph. Look at a quick example:

---
NeoService neo = // An arbitrary NeoService instance
IndexService index = new LuceneIndexService( neo );

// Create a node with a "name" property and index it in the IndexService.
Node personNode = neo.createNode();
personNode.setProperty( "name", "Mattias Persson" );
index.index( personNode, "name", personNode.getProperty( "name" ) );

// Get the node with the name "Mattias Persson"
Node node = index.getSingleNode( "name", "Mattias Persson" );
// also see index.getNodes method.
assert personNode.equals( node );
---

	Read more at our {{{http://wiki.neo4j.org/content/Indexing_with_IndexService}wiki}}
	
LuceneIndexBatchInserter

	See more information about the LuceneIndexBatchInserter on our
	wiki

BTree, BTreeMap

	In <<org.neo4j.util.btree>> package you'll find a
	{{{http://en.wikipedia.org/wiki/B-tree}b-tree}} implementation on top of
	neo4j. You supply a root node to the <<BTree>> instance and the b-tree will
	be created in connection to it.

	You can also expose a <<BTree>> as a <<java.util.Map>> using the
	<<org.neo4j.util.map.BTreeMap>> class where the values (in the key-value
	pairs) can be any of the supported property types in neo4j.

Timeline

	You can create a timeline and add nodes to it, each with a timestamp and you
	can then ask it to return all nodes within a specific period of time
	(with optional upper and lower bounds).
	
	Node that the name you give the timeline is more a convenience thing, much
	like the naming of a Thread in Java. It is also a security check so that
	you use the right timeline, since the name is checked upon instantiation
	so that it is the same as the name as you pass in (except the first time).

---
Node rootNode = // Some node which you dedicate as the timeline root.
Timeline timeline = new Timeline( "my_timeline", rootNode, neo );

// Add nodes to your timeline
long startTime = System.currentTimeMillis();
for ( int i = 0; i < 50000; i++ )
{
    timeline.addNode( neo.createNode(), System.currentTimeMillis() );
    Thread.sleep( new Random().nextInt( 30 ) );
}

// Get all the nodes in the timeline
Iterable<Node> nodes = timeline.getAllNodes();
// All nodes after timestamp (3 seconds after the start time)
nodes = timeline.getAllNodesAfter( startTime + 3000 );
// All nodes before timestamp
nodes = timeline.getAllNodesBefore( System.currentTimeMillis() );
// All nodes between these timestamps
nodes = timeline.getAllNodesBetween( startTime, System.currentTimeMillis() - 5000 );
---

	Although values from System.currentTimeMillis() is used in this example
	you can use any value system (of type long) for your timestamps.